name: Stage 2 - Staging Deployment Pipeline

on:
  # Triggered by Stage 1 workflow when images are successfully uploaded to ACR
  repository_dispatch:
    types: [stage2_deploy]
  
  # Manual trigger for testing purposes
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        default: 'latest'

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  # Use image tag from Stage 1 trigger or manual input
  IMAGE_TAG: ${{ github.event.client_payload.image_tag || github.event.inputs.image_tag || 'latest' }}
  # Create unique staging environment names
  STAGING_RG: rg-staging-${{ github.event.client_payload.run_id || github.run_id }}
  STAGING_AKS: aks-staging-${{ github.event.client_payload.run_id || github.run_id }}

jobs:
  # Job 1: Create Staging Infrastructure
  create_staging_infrastructure:
    runs-on: ubuntu-latest
    
    outputs:
      staging-rg: ${{ env.STAGING_RG }}
      staging-aks: ${{ env.STAGING_AKS }}
      image-tag: ${{ env.IMAGE_TAG }}

    steps:
      - name: Display Trigger Information
        run: |
          echo "üöÄ Stage 2 Pipeline Triggered"
          echo "Image Tag: ${{ env.IMAGE_TAG }}"
          echo "Staging Resource Group: ${{ env.STAGING_RG }}"
          echo "Staging AKS Cluster: ${{ env.STAGING_AKS }}"
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            echo "Triggered by: Stage 1 completion"
            echo "Original commit: ${{ github.event.client_payload.commit_sha }}"
          else
            echo "Triggered by: Manual workflow dispatch"
          fi

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Staging Resource Group
        run: |
          echo "üì¶ Creating staging resource group..."
          az group create \
            --name ${{ env.STAGING_RG }} \
            --location australiaeast \
            --tags Environment=Staging Purpose=Testing AutoDelete=true

      - name: Create Staging AKS Cluster
        run: |
          echo "üîß Creating staging AKS cluster..."
          az aks create \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --node-count 1 \
            --node-vm-size Standard_B2s \
            --generate-ssh-keys \
            --attach-acr ${{ env.ACR_LOGIN_SERVER }} \
            --tags Environment=Staging Purpose=Testing AutoDelete=true

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --overwrite-existing

      - name: Verify Cluster Connection
        run: |
          echo "‚úÖ Verifying cluster connectivity..."
          kubectl get nodes
          kubectl cluster-info

  # Job 2: Deploy Applications to Staging
  deploy_to_staging:
    runs-on: ubuntu-latest
    needs: create_staging_infrastructure
    if: success()

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --overwrite-existing

      - name: Create Kubernetes Namespace
        run: |
          echo "üéØ Setting up staging namespace..."
          kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Database Services
        run: |
          echo "üóÑÔ∏è Deploying database services..."
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: product-db
            namespace: staging
            labels:
              app: product-db
              environment: staging
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: product-db
            template:
              metadata:
                labels:
                  app: product-db
                  environment: staging
              spec:
                containers:
                - name: postgres
                  image: postgres:15
                  env:
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  - name: POSTGRES_DB
                    value: products
                  ports:
                  - containerPort: 5432
                  readinessProbe:
                    exec:
                      command:
                        - pg_isready
                        - -U
                        - postgres
                    initialDelaySeconds: 5
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: product-db-service
            namespace: staging
          spec:
            selector:
              app: product-db
            ports:
            - port: 5432
              targetPort: 5432
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: order-db
            namespace: staging
            labels:
              app: order-db
              environment: staging
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: order-db
            template:
              metadata:
                labels:
                  app: order-db
                  environment: staging
              spec:
                containers:
                - name: postgres
                  image: postgres:15
                  env:
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  - name: POSTGRES_DB
                    value: orders
                  ports:
                  - containerPort: 5432
                  readinessProbe:
                    exec:
                      command:
                        - pg_isready
                        - -U
                        - postgres
                    initialDelaySeconds: 5
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: order-db-service
            namespace: staging
          spec:
            selector:
              app: order-db
            ports:
            - port: 5432
              targetPort: 5432
          EOF

      - name: Wait for Databases to be Ready
        run: |
          echo "‚è≥ Waiting for databases to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/product-db -n staging
          kubectl wait --for=condition=available --timeout=300s deployment/order-db -n staging
          echo "‚úÖ Databases are ready!"

      - name: Deploy Application Services
        run: |
          echo "üöÄ Deploying application services with image tag: ${{ env.IMAGE_TAG }}"
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: product-service
            namespace: staging
            labels:
              app: product-service
              environment: staging
              version: "${{ env.IMAGE_TAG }}"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: product-service
            template:
              metadata:
                labels:
                  app: product-service
                  environment: staging
              spec:
                containers:
                - name: product-service
                  image: ${{ env.ACR_LOGIN_SERVER }}/product_service:${{ env.IMAGE_TAG }}
                  env:
                  - name: POSTGRES_HOST
                    value: product-db-service
                  - name: POSTGRES_PORT
                    value: "5432"
                  - name: POSTGRES_DB
                    value: products
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  ports:
                  - containerPort: 8000
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 45
                    periodSeconds: 30
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: product-service
            namespace: staging
          spec:
            selector:
              app: product-service
            ports:
            - port: 8000
              targetPort: 8000
            type: LoadBalancer
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: order-service
            namespace: staging
            labels:
              app: order-service
              environment: staging
              version: "${{ env.IMAGE_TAG }}"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: order-service
            template:
              metadata:
                labels:
                  app: order-service
                  environment: staging
              spec:
                containers:
                - name: order-service
                  image: ${{ env.ACR_LOGIN_SERVER }}/order_service:${{ env.IMAGE_TAG }}
                  env:
                  - name: POSTGRES_HOST
                    value: order-db-service
                  - name: POSTGRES_PORT
                    value: "5432"
                  - name: POSTGRES_DB
                    value: orders
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  ports:
                  - containerPort: 8001
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8001
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8001
                    initialDelaySeconds: 45
                    periodSeconds: 30
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: order-service
            namespace: staging
          spec:
            selector:
              app: order-service
            ports:
            - port: 8001
              targetPort: 8001
            type: LoadBalancer
          EOF

      - name: Wait for Application Services to be Ready
        run: |
          echo "‚è≥ Waiting for application services to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/product-service -n staging
          kubectl wait --for=condition=available --timeout=300s deployment/order-service -n staging
          echo "‚úÖ Application services are ready!"

      - name: Get Staging Environment URLs
        run: |
          echo "üåê Retrieving staging environment URLs..."
          kubectl get services -n staging
          
          # Wait for external IPs with timeout
          echo "‚è≥ Waiting for LoadBalancer external IPs..."
          timeout 300 bash -c '
          while [[ $(kubectl get svc product-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null) == "" ]]; do
            echo "Waiting for product-service external IP..."
            sleep 15
          done
          while [[ $(kubectl get svc order-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null) == "" ]]; do
            echo "Waiting for order-service external IP..."
            sleep 15
          done
          ' || echo "‚ö†Ô∏è  LoadBalancer IPs may take additional time to provision"
          
          PRODUCT_SERVICE_IP=$(kubectl get svc product-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "pending")
          ORDER_SERVICE_IP=$(kubectl get svc order-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "pending")
          
          echo ""
          echo "üéâ STAGING ENVIRONMENT DEPLOYED SUCCESSFULLY!"
          echo "================================================"
          echo "üè∑Ô∏è  Image Version: ${{ env.IMAGE_TAG }}"
          echo "üåç Environment: ${{ env.STAGING_RG }}"
          echo ""
          echo "üì± Service URLs:"
          echo "   Product Service: http://$PRODUCT_SERVICE_IP:8000"
          echo "   Order Service: http://$ORDER_SERVICE_IP:8001"
          echo ""
          echo "üîç Health Check URLs:"
          echo "   Product Health: http://$PRODUCT_SERVICE_IP:8000/health"
          echo "   Order Health: http://$ORDER_SERVICE_IP:8001/health"
          echo ""
          echo "üìä API Documentation:"
          echo "   Product API: http://$PRODUCT_SERVICE_IP:8000/docs"
          echo "   Order API: http://$ORDER_SERVICE_IP:8001/docs"
          echo "================================================"

  # Job 3: Run Staging Tests
  run_staging_tests:
    runs-on: ubuntu-latest
    needs: deploy_to_staging
    if: success()

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --overwrite-existing

      - name: Wait for Services to be Fully Ready
        run: |
          echo "‚è≥ Ensuring all services are fully operational..."
          sleep 60  # Give services additional time to fully initialize

      - name: Get Service IPs
        id: get_ips
        run: |
          PRODUCT_SERVICE_IP=$(kubectl get svc product-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
          ORDER_SERVICE_IP=$(kubectl get svc order-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
          
          echo "product_ip=$PRODUCT_SERVICE_IP" >> $GITHUB_OUTPUT
          echo "order_ip=$ORDER_SERVICE_IP" >> $GITHUB_OUTPUT
          
          echo "Product Service IP: $PRODUCT_SERVICE_IP"
          echo "Order Service IP: $ORDER_SERVICE_IP"

      - name: Run Basic Health Checks
        run: |
          echo "üè• Running health checks..."
          
          # Product Service Health Check
          echo "Testing Product Service Health..."
          for i in {1..5}; do
            if curl -f -s http://${{ steps.get_ips.outputs.product_ip }}:8000/health; then
              echo "‚úÖ Product Service health check passed"
              break
            else
              echo "‚è≥ Product Service not ready yet (attempt $i/5)"
              sleep 30
            fi
          done
          
          # Order Service Health Check  
          echo "Testing Order Service Health..."
          for i in {1..5}; do
            if curl -f -s http://${{ steps.get_ips.outputs.order_ip }}:8001/health; then
              echo "‚úÖ Order Service health check passed"
              break
            else
              echo "‚è≥ Order Service not ready yet (attempt $i/5)"
              sleep 30
            fi
          done

      - name: Run Simple Acceptance Tests
        run: |
          echo "üß™ Running acceptance tests..."
          
          PRODUCT_IP=${{ steps.get_ips.outputs.product_ip }}
          ORDER_IP=${{ steps.get_ips.outputs.order_ip }}
          
          # Test Product Service API endpoints
          echo "Testing Product Service APIs..."
          
          # Get products (should return empty list initially)
          echo "  - Testing GET /products"
          curl -f -s "http://$PRODUCT_IP:8000/products" || exit 1
          
          # Test Order Service API endpoints
          echo "Testing Order Service APIs..."
          
          # Get orders (should return empty list initially)
          echo "  - Testing GET /orders"  
          curl -f -s "http://$ORDER_IP:8001/orders" || exit 1
          
          echo "‚úÖ All acceptance tests passed!"

      - name: Manual Testing Phase
        run: |
          echo ""
          echo "üîç MANUAL TESTING PHASE"
          echo "=================================="
          echo "The staging environment is now ready for manual testing."
          echo ""
          echo "üåê Access URLs:"
          echo "   Product Service: http://${{ steps.get_ips.outputs.product_ip }}:8000"
          echo "   Order Service: http://${{ steps.get_ips.outputs.order_ip }}:8001"
          echo ""
          echo "üìñ API Documentation:"
          echo "   Product API Docs: http://${{ steps.get_ips.outputs.product_ip }}:8000/docs"
          echo "   Order API Docs: http://${{ steps.get_ips.outputs.order_ip }}:8001/docs"
          echo ""
          echo "‚ö†Ô∏è  IMPORTANT: This environment will be automatically destroyed"
          echo "    after the testing phase completes."
          echo ""
          echo "üìã Manual Testing Checklist:"
          echo "   ‚ñ° Test product creation and retrieval"
          echo "   ‚ñ° Test order creation and retrieval"
          echo "   ‚ñ° Verify API documentation is accessible"
          echo "   ‚ñ° Check application performance and responsiveness"
          echo ""
          echo "‚è±Ô∏è  Environment will remain active for additional testing..."
          
          # Keep environment active for manual testing
          echo "Staging environment active for manual testing..."
          sleep 300  # 5 minutes for manual testing

  # Job 4: Destroy Staging Environment
  destroy_staging_environment:
    runs-on: ubuntu-latest
    needs: [create_staging_infrastructure, deploy_to_staging, run_staging_tests]
    if: always() && needs.create_staging_infrastructure.result == 'success'

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Cleanup Staging Environment
        run: |
          echo "üßπ CLEANING UP STAGING ENVIRONMENT"
          echo "=================================="
          echo "Resource Group: ${{ env.STAGING_RG }}"
          echo ""
          
          # Check if resource group exists before attempting deletion
          if az group exists --name ${{ env.STAGING_RG }}; then
            echo "üóëÔ∏è  Deleting staging resource group and all resources..."
            az group delete \
              --name ${{ env.STAGING_RG }} \
              --yes \
              --no-wait
            
            echo "‚úÖ Staging environment cleanup initiated successfully"
            echo ""
            echo "üìù Cleanup Summary:"
            echo "   - Resource Group: ${{ env.STAGING_RG }} (deletion in progress)"
            echo "   - AKS Cluster: ${{ env.STAGING_AKS }} (being deleted)"
            echo "   - All associated resources will be removed automatically"
            echo ""
            echo "üí° The deletion process runs asynchronously and may take several minutes to complete."
          else
            echo "‚ö†Ô∏è  Resource group ${{ env.STAGING_RG }} not found. May have been deleted already."
          fi

      - name: Deployment Summary
        run: |
          echo ""
          echo "üìä STAGE 2 DEPLOYMENT SUMMARY"
          echo "============================="
          echo "‚úÖ Staging infrastructure created successfully"
          echo "‚úÖ Applications deployed with image tag: ${{ env.IMAGE_TAG }}"
          echo "‚úÖ Health checks and acceptance tests completed"
          echo "‚úÖ Manual testing phase completed"
          echo "‚úÖ Environment cleanup initiated"
          echo ""
          echo "üéâ Stage 2 pipeline completed successfully!"