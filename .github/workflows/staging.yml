name: Stage 2 - Staging Deployment Pipeline

on:

  workflow_call:

  # Manual trigger for testing purposes
  workflow_dispatch:


env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  # Use image tag from Stage 1 trigger or manual input
  IMAGE_TAG: ${{ github.event.client_payload.image_tag || github.event.inputs.image_tag || 'latest' }}
  # Create unique staging environment names
  STAGING_RG: week10rudra-rg
  STAGING_AKS: aks-staging-${{ github.event.client_payload.run_id || github.run_id }}

jobs:
  # Job 1: Create Staging Infrastructure
  create_staging_infrastructure:
    runs-on: ubuntu-latest
    
    outputs:
      staging-rg: ${{ env.STAGING_RG }}
      staging-aks: ${{ env.STAGING_AKS }}
      image-tag: latest

    steps:
      - name: Display Trigger Information
        run: |
          echo " Stage 2 Pipeline Triggered"
          echo "Image Tag: latest"
          echo "Staging Resource Group: ${{ env.STAGING_RG }}"
          echo "Staging AKS Cluster: ${{ env.STAGING_AKS }}"


      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # - name: Create Staging Resource Group
      #   run: |
      #     echo " Creating staging resource group..."
      #     az group create \
      #       --name ${{ env.STAGING_RG }} \
      #       --location australiaeast \
      #       --tags Environment=Staging Purpose=Testing AutoDelete=true

      - name: Create Staging AKS Cluster
        run: |
          echo " Creating staging AKS cluster..."
          az aks create \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --node-count 1 \
            --node-vm-size Standard_B2s \
            --generate-ssh-keys \
            --attach-acr ${{ env.ACR_LOGIN_SERVER }} \
            --tags Environment=Staging Purpose=Testing AutoDelete=true

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --overwrite-existing

      - name: Verify Cluster Connection
        run: |
          echo " Verifying cluster connectivity..."
          kubectl get nodes
          kubectl cluster-info

  # Job 2: Deploy Applications to Staging
  deploy_to_staging:
    runs-on: ubuntu-latest
    needs: create_staging_infrastructure
    if: success()

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --overwrite-existing

      - name: Create Kubernetes Namespace
        run: |
          echo "üéØ Setting up staging namespace..."
          kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Database Services
        run: |
          echo "üóÑÔ∏è Deploying database services..."
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: product-db
            namespace: staging
            labels:
              app: product-db
              environment: staging
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: product-db
            template:
              metadata:
                labels:
                  app: product-db
                  environment: staging
              spec:
                containers:
                - name: postgres
                  image: postgres:15
                  env:
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  - name: POSTGRES_DB
                    value: products
                  ports:
                  - containerPort: 5432
                  readinessProbe:
                    exec:
                      command:
                        - pg_isready
                        - -U
                        - postgres
                    initialDelaySeconds: 5
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: product-db-service
            namespace: staging
          spec:
            selector:
              app: product-db
            ports:
            - port: 5432
              targetPort: 5432
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: order-db
            namespace: staging
            labels:
              app: order-db
              environment: staging
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: order-db
            template:
              metadata:
                labels:
                  app: order-db
                  environment: staging
              spec:
                containers:
                - name: postgres
                  image: postgres:15
                  env:
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  - name: POSTGRES_DB
                    value: orders
                  ports:
                  - containerPort: 5432
                  readinessProbe:
                    exec:
                      command:
                        - pg_isready
                        - -U
                        - postgres
                    initialDelaySeconds: 5
                    periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: order-db-service
            namespace: staging
          spec:
            selector:
              app: order-db
            ports:
            - port: 5432
              targetPort: 5432
          EOF

      - name: Wait for Databases to be Ready
        run: |
          echo "‚è≥ Waiting for databases to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/product-db -n staging
          kubectl wait --for=condition=available --timeout=300s deployment/order-db -n staging
          echo "‚úÖ Databases are ready!"

      - name: Deploy Application Services
        run: |
          echo " Deploying application services with image tag: latest"
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: product-service
            namespace: staging
            labels:
              app: product-service
              environment: staging
              version: "latest"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: product-service
            template:
              metadata:
                labels:
                  app: product-service
                  environment: staging
              spec:
                containers:
                - name: product-service
                  image: ${{ env.ACR_LOGIN_SERVER }}/product_service:latest
                  env:
                  - name: POSTGRES_HOST
                    value: product-db-service
                  - name: POSTGRES_PORT
                    value: "5432"
                  - name: POSTGRES_DB
                    value: products
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  ports:
                  - containerPort: 8000
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 45
                    periodSeconds: 30
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: product-service
            namespace: staging
          spec:
            selector:
              app: product-service
            ports:
            - port: 8000
              targetPort: 8000
            type: LoadBalancer
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: order-service
            namespace: staging
            labels:
              app: order-service
              environment: staging
              version: "latest"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: order-service
            template:
              metadata:
                labels:
                  app: order-service
                  environment: staging
              spec:
                containers:
                - name: order-service
                  image: ${{ env.ACR_LOGIN_SERVER }}/order_service:latest
                  env:
                  - name: POSTGRES_HOST
                    value: order-db-service
                  - name: POSTGRES_PORT
                    value: "5432"
                  - name: POSTGRES_DB
                    value: orders
                  - name: POSTGRES_USER
                    value: postgres
                  - name: POSTGRES_PASSWORD
                    value: postgres
                  ports:
                  - containerPort: 8001
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8001
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8001
                    initialDelaySeconds: 45
                    periodSeconds: 30
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: order-service
            namespace: staging
          spec:
            selector:
              app: order-service
            ports:
            - port: 8001
              targetPort: 8001
            type: LoadBalancer
          EOF

      - name: Wait for Application Services to be Ready
        run: |
          echo "‚è≥ Waiting for application services to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/product-service -n staging
          kubectl wait --for=condition=available --timeout=300s deployment/order-service -n staging
          echo "‚úÖ Application services are ready!"

      - name: Get Staging Environment URLs
        run: |
          echo " Retrieving staging environment URLs..."
          kubectl get services -n staging
          
          # Wait for external IPs with timeout
          echo " Waiting for LoadBalancer external IPs..."
          timeout 300 bash -c '
          while [[ $(kubectl get svc product-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null) == "" ]]; do
            echo "Waiting for product-service external IP..."
            sleep 15
          done
          while [[ $(kubectl get svc order-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null) == "" ]]; do
            echo "Waiting for order-service external IP..."
            sleep 15
          done
          ' || echo "  LoadBalancer IPs may take additional time to provision"
          
          PRODUCT_SERVICE_IP=$(kubectl get svc product-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "pending")
          ORDER_SERVICE_IP=$(kubectl get svc order-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null || echo "pending")
          
    
          echo " STAGING ENVIRONMENT DEPLOYED SUCCESSFULLY!"
 

  # Job 3: Run Staging Tests
  run_staging_tests:
    runs-on: ubuntu-latest
    needs: deploy_to_staging
    if: success()

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.STAGING_RG }} \
            --name ${{ env.STAGING_AKS }} \
            --overwrite-existing

      - name: Wait for Services to be Fully Ready
        run: |
          echo " Ensuring all services are fully operational..."
          sleep 60  # Give services additional time to fully initialize

      - name: Get Service IPs
        id: get_ips
        run: |
          PRODUCT_SERVICE_IP=$(kubectl get svc product-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
          ORDER_SERVICE_IP=$(kubectl get svc order-service -n staging -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
          
          echo "product_ip=$PRODUCT_SERVICE_IP" >> $GITHUB_OUTPUT
          echo "order_ip=$ORDER_SERVICE_IP" >> $GITHUB_OUTPUT
          
          echo "Product Service IP: $PRODUCT_SERVICE_IP"
          echo "Order Service IP: $ORDER_SERVICE_IP"

      - name: Run Basic Health Checks
        run: |
          echo " Running health checks..."
          
          # Product Service Health Check
          echo "Testing Product Service Health..."
          for i in {1..5}; do
            if curl -f -s http://${{ steps.get_ips.outputs.product_ip }}:8000/health; then
              echo " Product Service health check passed"
              break
            else
              echo " Product Service not ready yet (attempt $i/5)"
              sleep 30
            fi
          done
          
          # Order Service Health Check  
          echo "Testing Order Service Health..."
          for i in {1..5}; do
            if curl -f -s http://${{ steps.get_ips.outputs.order_ip }}:8001/health; then
              echo " Order Service health check passed"
              break
            else
              echo " Order Service not ready yet (attempt $i/5)"
              sleep 30
            fi
          done

      - name: Run Simple Acceptance Tests
        run: |
          echo " Running acceptance tests..."
          
          PRODUCT_IP=${{ steps.get_ips.outputs.product_ip }}
          ORDER_IP=${{ steps.get_ips.outputs.order_ip }}
          
          # Test Product Service API endpoints
          echo "Testing Product Service APIs..."
          
          # Get products (should return empty list initially)
          echo "  - Testing GET /products"
          curl -f -s "http://$PRODUCT_IP:8000/products" || exit 1
          
          # Test Order Service API endpoints
          echo "Testing Order Service APIs..."
          
          # Get orders (should return empty list initially)
          echo "  - Testing GET /orders"  
          curl -f -s "http://$ORDER_IP:8001/orders" || exit 1
          
          echo " All acceptance tests passed!"

  
  # Job 4: Destroy Staging Environment
  destroy_staging_environment:
    runs-on: ubuntu-latest
    needs: [create_staging_infrastructure, deploy_to_staging, run_staging_tests]
    if: always() && needs.create_staging_infrastructure.result == 'success'

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Cleanup Staging Environment
        run: |
          echo "CLEANING UP STAGING ENVIRONMENT"
          
              echo "Deleting staging AKS cluster..."
              az aks delete \
                --name ${{ env.STAGING_AKS }} \
                --resource-group week10rudra-rg \
                --yes \
                --no-wait
                
            echo " The deletion process runs asynchronously and may take several minutes to complete."
          else
            echo "‚ö†Ô∏è  Resource group ${{ env.STAGING_RG }} not found. May have been deleted already."
          fi

  